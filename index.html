<!doctype html>  
<html lang="en">
<head>
	<meta charset="utf-8">
	
	<title>Tron - Yelp Learning Group</title>

	<meta name="description" content="Tron - Yelp learning group.">
	<meta name="author" content="Daniel Nephin">

	<meta name="apple-mobile-web-app-capable" content="yes" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
	
	<link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open Sans' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Port+Lligat+Sans|Press+Start+2P|Changa+One|Open+Sans:400,600,700' rel='stylesheet' type='text/css'>
	
	<link rel="stylesheet" href="css/reset.css">
	<link rel="stylesheet" href="css/main.css">
    <link rel="stylesheet/less" href="css/tron.css" type="text/css">
    <script src="js/less-1.3.0.min.js" type="text/javascript"></script>    

	<link rel="stylesheet" href="lib/zenburn.css">
</head>

<body>

<div class="reveal">

<!-- Used to fade in a background when a specific slide state is reached -->
<div class="state-background"></div>

<!-- Any section element inside of this container is displayed as a slide -->
<div class="slides">
<section id="slide_title">
	<h1>Tron</h1>
	<h3 class="fragment">Design Patterns</h3>
    <h4 class="fragment">and why code should be beautiful</h4>
</section>

<section id="slide_image_grid">
    <div class="container">
        <!-- grid -->
        <div><img src="imgs/apache.png" /></div>
        <div><img src="imgs/github.png" /></div>
        <div class="est">EST 2009</div>
        <div><img src="imgs/yelp.png" /></div>
        <div><img src="imgs/python.png" /></div>
        <div><img src="imgs/twisted.png" /></div>
        <div><img src="imgs/yaml.png" /></div>
        <div class="loc">15k loc</div>
        <div><img src="" /></div> <!-- no mascot -->
    </div>
</section>


<section id="slide_description">
     <p>Tron is a <span>centralized system</span> for managing <span>periodic batch processes</span> and <span>services</span> across a cluster.</p>
</section>

<section>
	<h2>Batch Processes</h2>
    <!-- TODO: icons instead of lists -->
	<ul>
        <li>scheduling</li>
        <li>execute on remote machines</li>
        <li>depedency management</li>
        <li>run history</li>
    </ul>
</section>

<section>
	<h2>Services</h2>
    <ul>
        <li>start/stop services</li>
        <li>execute on remote machines</li>
        <li>monitor and restart on failure</li>
    </ul>
</section>

<section>
    <h2>Centralized management</h2>
    <ul>
        <li>view state of batches and services</li>
        <li>persistent history of previous runs, and state changes</li>
        <li>web services interface (json)</li>
    </ul>
</section>

<section>
    <!-- TODO: icons for batch/service/management -->
    <p>What constructs do we expect to see to implement these features?</p>
</section>

<section>
    <h2>Constructs</h2>
    <ul>
        <li class="fragment">Configuration management</li>
        <li class="fragment">Web service API</li>
        <li class="fragment">State persistence</li>
        <li class="fragment">State machine</li>        
        <li class="fragment">Networking</li>
    </ul>
</section>

<section>
    <h2>Building blocks</h2>
    <ul>
        <li>twisted</li>
        <li>yaml</li>
    </ul>
</section>

<section>
    <h2>Configuration</h2>
    <!-- TODO: sample configuration old and new -->
</section>

<section>
    <h2>Web Service API</h2>
</section>

<section id="slide_state_persistence">
    <h2>State Persistence</h2>
    <!-- 140 lines -->
    <pre class="fragment"><code contenteditable>
class StateHandler(object):
    def __init__(self, mcp, working_dir, writing=False):
        self.mcp = mcp
        self.working_dir = working_dir
        self.write_pid = None
        self.write_start = None
        self.writing_enabled = writing
        self.store_delayed = False
        self.event_recorder = event.EventRecorder(self, parent=mcp.event_recorder)

    def restore_job(self, job_inst, data):
        job_inst.set_context(self.mcp.context)
        job_inst.restore(data)

        for run in job_inst.runs:
            if run.is_scheduled:
                reactor.callLater(sleep_time(run.run_time), self.mcp.run_job, run)

        next = job_inst.next_to_finish()
        if job_inst.enabled and next and next.is_queued:
            next.start()

    def restore_service(self, service, data):
        service.set_context(self.mcp.context)
        service.restore(data)

    def delay_store(self):
        self.store_delayed = False
        self.store_state()

    def check_write_child(self):
        if self.write_pid:
            pid, status = os.waitpid(self.write_pid, os.WNOHANG)
            if pid != 0:
                log.info("State writing completed in in %d seconds", timeutils.current_timestamp() - self.write_start)
                if status != 0:
                    log.warning("State writing process failed with status %d", status)
                    self.event_recorder.emit_critical("write_failed")
                else:
                    self.event_recorder.emit_ok("write_complete")
                self.write_pid = None
                self.write_start = None
            else:
                # Process hasn't exited
                write_duration = timeutils.current_timestamp() - self.write_start
                if write_duration > WRITE_DURATION_WARNING_SECS:
                    log.warning("State writing hasn't completed in %d secs", write_duration)
                    self.event_recorder.emit_notice("write_delayed")

                reactor.callLater(STATE_SLEEP_SECS, self.check_write_child)

    def store_state(self):
        """Stores the state of tron"""
        log.debug("store_state called: %r, %r", self.write_pid, self.writing_enabled)

        # If tron is already storing data, don't start again till it's done
        if self.write_pid or not self.writing_enabled:
            # If a child is writing, we don't want to ignore this change, so lets try it later
            if not self.store_delayed:
                self.store_delayed = True
                reactor.callLater(STATE_SLEEP_SECS, self.delay_store)
            return

        tmp_path = os.path.join(self.working_dir, '.tmp.' + STATE_FILE)
        file_path = os.path.join(self.working_dir, STATE_FILE)
        log.info("Storing state in %s", file_path)

        self.event_recorder.emit_info("storing")

        self.write_start = timeutils.current_timestamp()
        pid = os.fork()
        if pid:
            self.write_pid = pid
            reactor.callLater(STATE_SLEEP_SECS, self.check_write_child)
        else:
            exit_status = os.EX_SOFTWARE
            try:
                with open(tmp_path, 'w') as data_file:
                    yaml.dump(self.data, data_file, default_flow_style=False, indent=4)
                    data_file.flush()
                    os.fsync(data_file.fileno())
                shutil.move(tmp_path, file_path)
                exit_status = os.EX_OK
            except:
                log.exception("Failure while writing state")
            finally:
                os._exit(exit_status)

    def get_state_file_path(self):
        return os.path.join(self.working_dir, STATE_FILE)

    def load_data(self):
        log.info('Restoring state from %s', self.get_state_file_path())
        self.event_recorder.emit_notice("restoring")
        with open(self.get_state_file_path()) as data_file:
            return self._load_data_file(data_file)

    def _load_data_file(self, data_file):
        data = yaml.load(data_file)

        if 'version' not in data:
            # Pre-versioned state files need to be reformatted a bit
            data = {
                'version': [0, 1, 9],
                'jobs': data
            }

        # For properly comparing version, we need to convert this guy to a tuple
        data['version'] = tuple(data['version'])
        # By default we assume backwards compatability.
        if data['version'] == tron.__version_info__:
            return data
        elif data['version'] > tron.__version_info__:
            raise StateFileVersionError("State file has new version: %r", data['version'])
        elif data['version'] < (0, 2, 0):
            raise UnsupportedVersionError("State file has version %r" % (data['version'],))
        else:
            # Potential version conversions
            return data

    @property
    def data(self):
        data = {
            'version': tron.__version_info__,
            'create_time': int(time.time()),
            'jobs': {},
            'services': {},
        }

        for j in self.mcp.jobs.itervalues():
            data['jobs'][j.name] = j.data

        for s in self.mcp.services.itervalues():
            data['services'][s.name] = s.data

        return data

    def __str__(self):
        return "STATE_HANDLER"
    </code></pre>

    <pre class="fragment"><code contenteditable>
class PersistentStateManager(observer.Observer):
    """Provides an interface to persist the state of Tron.

    The implementation of persisting and restoring the state from disk is
    handled by a class which supports the StateStore interface:

    class IStateStore(object):

        def build_key(self, type, identifier):
            return &lt;a key&gt;

        def restore(self, keys):
            return &lt;dict of key to states&gt;

        def save(self, key, state_data):
            pass

        def cleanup(self):
            pass

    """

    def __init__(self, persistence_impl, buffer):
        self.enabled            = True
        self._buffer            = buffer
        self._impl              = persistence_impl
        self.metadata_key       = self._impl.build_key(
                                    runstate.MCP_STATE, StateMetadata.name)

    def restore(self, jobs, services):
        """Return the most recent serialized state."""
        log.debug("Restoring state.")
        self._restore_metadata()

        return (self._restore_dicts(runstate.JOB_STATE, jobs),
                self._restore_dicts(runstate.SERVICE_STATE, services))

    def _restore_metadata(self):
        metadata = self._impl.restore([self.metadata_key])
        StateMetadata.validate_metadata(metadata.get(self.metadata_key))

    def _keys_for_items(self, item_type, items):
        """Returns a dict of item to the key for that item."""
        make_key = self._impl.build_key
        keys = (make_key(item_type, item.name) for item in items)
        return dict(itertools.izip(keys, items))

   def _restore_dicts(self, item_type, items):
        """Return a dict mapping of the items name to its state data."""
        key_to_item_map  = self._keys_for_items(item_type, items)
        key_to_state_map = self._impl.restore(key_to_item_map.keys())
        return dict(
                (key_to_item_map[key].name, state_data)
                for key, state_data in key_to_state_map.iteritems())

    def _save(self, type_enum, item):
        """Persist an items state."""
        key = self._impl.build_key(type_enum, item.name)
        if self._buffer.save(key, item.state_data) and self.enabled:
            self._save_from_buffer()

    def _save_from_buffer(self):
        key_state_pairs = list(self._buffer)
        if not key_state_pairs:
            return

        keys = ','.join(str(key) for key, _ in key_state_pairs)
        log.debug("Saving state for %s" % keys)

        with self._timeit():
            try:
                self._impl.save(key_state_pairs)
            except Exception, e:
                msg = "Failed to save state for %s: %s" % (keys, e)
                log.warn(msg)
                raise PersistenceStoreError(msg)

    def save_job(self, job):
        self._save(runstate.JOB_STATE, job)

    def save_service(self, service):
        self._save(runstate.SERVICE_STATE, service)

    def save_metadata(self):
        self._save(runstate.MCP_STATE, StateMetadata())

    def cleanup(self):
        self._save_from_buffer()
        self._impl.cleanup()

    def handler(self, observable, _event):
        """Handle a state change in an observable by saving its state."""
        if isinstance(observable, job.Job):
            self.save_job(observable)
        if isinstance(observable, service.Service):
            self.save_service(observable)

    @contextmanager
    def disabled(self):
        """Temporarily disable the state manager."""
        self.enabled, prev_enabled = False, self.enabled
        try:
            yield
        finally:
            self.enabled = prev_enabled
    </code></pre>
</section>


<section>
    <h2>State Machine</h2>

    <pre class="fragment"><code contenteditable>
def mark_success(self):
    self.exit_status = 0
    self.end_time = timeutils.current_time()
    self.machine.transition('success')
    </code></pre>

    <pre class="fragment"><code contenteditable>
def success(self):
    if self.machine.transition('success'):
        self.exit_status = 0
        self.end_time    = timeutils.current_time()
        return True
    </code></pre>
</section>

<section>
    <h2>Networking</h2>
</section>

<section>
    <h2>Design Patterns!</h2>
    <img class="fragment" src="imgs/gang_of_four.jpg" />
</section>

<section>
    <h2>Observer/Observable</h2>
    <pre><code contenteditable>
class Observable(object):

    def __init__(self):
        self._observers = dict()

    def attach(self, watch_spec, observer):
        ...

    def notify(self, event):
        """Notify all observers of the event."""
        ...

 
class Observer(object):

    def watch(self, observable, event=True):
        """Adds this Observer as a watcher of the observable."""
        observable.attach(event, self)

    def handler(self, observable, event):
        """Override this method to call a method to handle events."""
        pass
    </code></pre>
</section>


<section>
    <h2>Factory</h2>
<!--     <pre class="fragment"><code>
def _make_action_run(self, job_run, action_inst, callback):
        action_run = action_inst.build_run(job_run)

        action_run.node = job_run.node

        action_run.machine.listen(True, self._notify)
        action_run.machine.listen(action.ActionRun.STATE_SUCCEEDED, callback)
        action_run.machine.listen(action.ActionRun.STATE_FAILED, callback)

        return action_run
    </code></pre> -->

    <pre class="fragment"><code contenteditable>
class PersistenceManagerFactory(object):
    """Create a PersistentStateManager."""

    @classmethod
    def from_config(cls, persistence_config):
        store_type              = persistence_config.store_type
        name                    = persistence_config.name
        connection_details      = persistence_config.connection_details
        buffer_size             = persistence_config.buffer_size
        store                   = None

        if store_type == 'shelve':
            store = ShelveStateStore(name)

        if store_type == 'sql':
            store = SQLAlchemyStateStore(name, connection_details)

        if store_type == 'mongo':
            store = MongoStateStore(name, connection_details)

        if store_type == 'yaml':
            store = YamlStateStore(name)

        if not store:
            raise PersistenceStoreError("Unknown store type: %s" % store_type)

        buffer = StateSaveBuffer(buffer_size)
        return PersistentStateManager(store, buffer)
    </code></pre>
</section>


<section>
    <h2>Collections</h2>
</section>


<section>
    <h2>Formatters</h2>
    <!-- Formatting was tied to www.py -->
</section>

<section>
    <p>hmm</p>
</section>

<section>
    <h2>Tests / Test Style</h2>
</section>

<section id="slide_whats_the_deal">
    <h4>So what's the deal?</h2>
    <h4 class="fragment">Code should be beautiful!</h4>
    <h4 class="fragment">Not convinced?</h4>
</section>

<section>
    <p>beautiful</p>
    <p class="fragment">aesthetically pleasing<p>
</section>

<section>
    <h2>Syntax Highlighting</h2>
</section>

<section>
    <h2>Warnings are Errors</h2>
</section>

<section>
    <h2>Zen of Python</h2>
    <pre id="zen">
>>> import this
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
...</pre>
</section>

<section id="analogy">
    <section>
        <h2>A Couple Analogies</h2>
        <!-- shark vs broken windows -->
        <img class="fragment" src="imgs/shark.png" />
        <div class="fragment">+</div>
        <img class="fragment" src="imgs/broken_windows.png" />

    </section>
    <section>
        <!-- TODO: graph of quality to time -->
    </section>
</section>

<section>
    <p>Readability impacts functional quality</p>
</section>

<section>
    <p>So how do we make code beautiful?</p>
    <!-- ACM issue 12/2011 art in the science -->
</section>

<section>
    <h2>White Space and Structure</h2>
    <!-- alignment, indentation, guards, etc -->
    <!-- program as a table -->
    <!-- max 80 character lines -->
</section>

<section>
    <h2>Context</h2>
    <!-- domain language -->
</section>


<section>
    <h2>Naming</h2>
    <!-- design patterns come in here a lot -->
</section>


<section>
    <h2>Code over Comments</h2>
    <!-- self documenting code, comments can lie, etc -->
</section>


<section>
    <h2>Design Patterns</h2>
    <!-- code to an interface -->
</section>


<section>
    <h2>Tests</h2>
    <!-- before code, synchronously -->
</section>


<section>
    <h2>Keep it short</h2>
    <!-- portability, maintainability, understanding -->
</section>


<section>
    <p>Read your code!</p>
</section>


<section>
    <p>... and back to Tron</p>
</section>

<section>
    <h2>Named configuration</h2>
</section>

<section>
    <h2>Better Interfaces</h2>
    <!-- dashboard, cli -->
</section>


<section>
    <h2>Client Daemons</h2>
</section>

<section>
    <h2>High Availability</h2>
</section>


<section>
    <p>... a stable release</p>
</section>


<section>
    <h2>Greater Adoption</h2>
    <!-- docs, blog posts -->
</section>


<section>
    <h2>Thanks!</h2>
    <!-- TODO: sjohnson++ -->
</section>


<section id="slide_end">
	<h1>The End</h1>
    <h3>Thank you!</h3>
</section>
</div>

<!-- The navigational controls UI -->
<aside class="controls">
	<a class="left" href="#">&#x25C4;</a>
	<a class="right" href="#">&#x25BA;</a>
	<a class="up" href="#">&#x25B2;</a>
	<a class="down" href="#">&#x25BC;</a>
</aside>

<!-- Displays presentation progress, max value changes via JS to reflect # of slides -->
<div class="progress"><span></span></div>
	
</div>

<!-- Optional libraries for code syntax highlighting and classList support in IE9 -->
<script src="lib/highlight.js"></script>
<script src="lib/classList.js"></script>

<script src="js/reveal.js"></script>

<script>
	// Fires each time a new slide is activated
	Reveal.addEventListener( 'slidechanged', function( event ) {
		// event.previousSlide, event.currentSlide, event.indexh, event.indexv
	} );

	Reveal.initialize({
		// Display controls in the bottom right corner
		controls: false,

		// Display a presentation progress bar
		progress: true,

		// If true; each slide will be pushed to the browser history
		history: true,

		// Loops the presentation, defaults to false
		loop: false,

		// Flags if mouse wheel navigation should be enabled
		mouseWheel: false,

		// Apply a 3D roll to links on hover
		rollingLinks: false,

		// UI style
		theme: 'default', // default/neon

		// Transition style
		transition: 'default' // default/cube/page/concave/linear(2d)
	});

	hljs.initHighlightingOnLoad();
</script>
</body>
</html>